"
This is a benchmark to measure the efficiency of test generation by an AICodeAssistant.
Essentially a test generated by the AI should exercise the code for which it was generated.
"
Class {
	#name : 'AITestGenerationBenchmark',
	#superclass : 'AICodeAssistantBenchmark',
	#instVars : [
		'numIterations',
		'maxAttempts',
		'targetMethods',
		'initialHistoryIndex'
	],
	#category : 'AICodeAssistant-Benchmarks',
	#package : 'AICodeAssistant',
	#tag : 'Benchmarks'
}

{ #category : 'private' }
AITestGenerationBenchmark >> generateTestsFor: aCompiledMethod [

	| tests result attempt |
	tests := (assistant
		          clearHistory;
		          writeTestsForMethod: aCompiledMethod) methods.
	tests do: [ :test |
		result := self tryTestCode: test sourceCode.
		attempt := 1.
		[ result hasPassed not and: [ attempt < maxAttempts ] ] whileTrue: [
			result := self tryToSolveIssuesOf: result.
			attempt := attempt + 1 ].
		result testedMethod: aCompiledMethod.
		results add: result ]
]

{ #category : 'initialization' }
AITestGenerationBenchmark >> initialize [

	super initialize.
	numIterations := 5.
	maxAttempts := 2.
	assistant beTestsGenerator
]

{ #category : 'parameters' }
AITestGenerationBenchmark >> maxAttempts: aNumber [

	maxAttempts := aNumber
]

{ #category : 'parameters' }
AITestGenerationBenchmark >> numIterations: aNumber [

	numIterations := aNumber
]

{ #category : 'private' }
AITestGenerationBenchmark >> restoreHistory [

	assistant keepHistoryUpTo: initialHistoryIndex 
]

{ #category : 'running' }
AITestGenerationBenchmark >> run [
	"
	self new run
	"
	numIterations timesRepeat: [
		targetMethods do: [ :method | self generateTestsFor: method ] ]
]

{ #category : 'results' }
AITestGenerationBenchmark >> showPlot [

	| plot categories grouped data cluster methods color k |
	categories := AITestGenerationResult availableStatuses.
	grouped := Dictionary new.
	results do: [ :r |
		(grouped at: r testedMethod ifAbsentPut: [ OrderedCollection new ])
			add: r ].
	methods := grouped keys asArray.
	categories do: [ :status |
		data := methods collect: [ :m |
			        k := (grouped at: m) count: [ :r | r status = status ].
			        k asFloat / (grouped at: m) size ].
		cluster := RSBarPlotNew new data: data.
		color := status = #invalid
			         ifTrue: [ Color black ]
			         ifFalse: [
				         status = #passed
					         ifTrue: [ Color green ]
					         ifFalse: [
						         status = #failed
							         ifTrue: [ Color orange ]
							         ifFalse: [ Color red ] ] ].
		cluster color: color.
		plot := plot ifNil: [ cluster ] ifNotNil: [ plot + cluster ] ].
	plot
		title: 'Test generation benchmark (' , assistant interfaceName , ')';
		xlabel:
			' black = invalid, green = passed, orange = failed, red = error ';
		xTickLabels: (methods collect: #selector).
	^ plot open
]

{ #category : 'parameters' }
AITestGenerationBenchmark >> targetMethods: aCollection [
	
		targetMethods := aCollection

]

{ #category : 'private' }
AITestGenerationBenchmark >> tryOvercomeCompilationError: anAITestAssistantResult [

	| prompt answer code |
	prompt := String streamContents: [ :strm |
		          strm
			          nextPutAll:
				          'The code you have provided resulted in the compilation error: ';
			          nextPutAll: anAITestAssistantResult error description;
			          nextPutAll: '. Provide a version that does not fail.' ].
	answer := assistant
		          clearPromptContext;
		          sendPrompt:
			          prompt
			          , ' Enclose the code between <test> and </test> tags'.
	code := (answer partTaggedWith: 'test') ifNil: [ '' ].
	^ self tryTestCode: code trim
]

{ #category : 'private' }
AITestGenerationBenchmark >> tryTestCode: aString [

	| result selector suite test testResult error |
	result := AITestGenerationResult new
		          conversation: assistant messages copy;
		          testCode: aString.
	[ self tryToCompile: aString in: AIGeneratedTest ]
		on: Error
		do: [ :e | ^ result beInvalidWith: e ].
	selector := AIGeneratedTest compile: 'test_AiGenerated_' , aString.
	suite := TestSuite named: selector.
	test := AIGeneratedTest selector: selector.
	suite addTest: test.
	testResult := suite run.
	testResult hasErrors ifTrue: [
		[ test runCase ]
			on: Error
			do: [ :e | error := e ].
		^ result beErrorWith: error ].
	testResult hasFailures
		ifTrue: [ result beFailureWith: testResult failures anyOne ]
		ifFalse: [ result bePassed ].
	^ result
]

{ #category : 'private' }
AITestGenerationBenchmark >> tryToCompile: aString in: aClass [

	OpalCompiler new
		source: aString;
		class: aClass;
		compile
]

{ #category : 'private' }
AITestGenerationBenchmark >> tryToOvercomeError: anAITestAssistantResult [

	| error intro description answer code |
	error := anAITestAssistantResult error.
	intro := String streamContents: [ :strm |
		         strm
			         nextPutAll: 'This test you have provided <test>';
			         nextPutAll: anAITestAssistantResult testCode;
			         nextPutAll: '</test> resulted in ' ].

	description := error class == MessageNotUnderstood
		               ifTrue: [
			               String streamContents: [ :strm |
				               strm
					               nextPutAll:
						               'a MessageNotUnderstood exception since ';
					               nextPutAll: error message selector;
					               nextPutAll:
						               ' is not understood by an instance of ';
					               nextPutAll: error receiver class name;
					               nextPutAll:
						               '. Provide a better version based on the the following messages that object understands: '.
				               error receiver class selectors
					               do: [ :s | strm nextPutAll: s ]
					               separatedBy: [ strm nextPut: $, ].
				               strm cr ] ]
		               ifFalse: [
			               String streamContents: [ :strm |
				               strm
					               nextPutAll: 'the following exception: ';
					               nextPutAll: error description;
					               nextPutAll:
						               '. Provide a version that does not fall into this exception.';
					               cr ] ].
	answer := assistant
		          clearPromptContext;
		          sendPrompt: intro , description
			          , ' Enclose the code between <test> and </test> tags'.
	code := (answer partTaggedWith: 'test') ifNil: [ '' ].
	^ self tryTestCode: code trim
]

{ #category : 'private' }
AITestGenerationBenchmark >> tryToOvercomeFailure: anAITestAssistantResult [

	| description prompt answer code |
	[ anAITestAssistantResult failure performTest ]
		on: Exception
		do: [ :e | description := e description ].
	prompt := String streamContents: [ :strm |
		          strm
			          nextPutAll:
				          'The code you have provided resulted in the following failure: ';
			          nextPutAll: description;
			          nextPutAll: '. Provide a version that does not fail.' ].
	answer := assistant
		          clearPromptContext;
		          sendPrompt:
			          prompt
			          , ' Enclose the code between <test> and </test> tags'.
	code := (answer partTaggedWith: 'test') ifNil: [ '' ].
	^ self tryTestCode: code trim
]

{ #category : 'private' }
AITestGenerationBenchmark >> tryToSolveIssuesOf: anAITestAssistantResult [

	anAITestAssistantResult isInvalid ifTrue: [
		^ self tryOvercomeCompilationError: anAITestAssistantResult ].
	anAITestAssistantResult hasError ifTrue: [
		^ self tryToOvercomeError: anAITestAssistantResult ].
	^ self tryToOvercomeFailure: anAITestAssistantResult
]
